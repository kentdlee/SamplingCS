<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Lesson 12: Photon Torpedoes!</title>
<style type="text/css"> 
<!-- 
body  {
	font: 100% Verdana, Arial, Helvetica, sans-serif;
	background: #666666;
	margin: 0; /* it's good practice to zero the margin and padding of the body element to account for differing browser defaults */
	padding: 0;
	text-align: center; /* this centers the container in IE 5* browsers. The text is then set to the left aligned default in the #container selector */
	color: #000000;
}

/* Tips for Elastic layouts 
1. Since the elastic layouts overall sizing is based on the user's default fonts size, they are more unpredictable. Used correctly, they are also more accessible for those that need larger fonts size since the line length remains proportionate.
2. Sizing of divs in this layout are based on the 100% font size in the body element. If you decrease the text size overall by using a font-size: 80% on the body element or the #container, remember that the entire layout will downsize proportionately. You may want to increase the widths of the various divs to compensate for this.
3. If font sizing is changed in differing amounts on each div instead of on the overall design (ie: #sidebar1 is given a 70% font size and #mainContent is given an 85% font size), this will proportionately change each of the divs overall size. You may want to adjust these divs based on your final font sizing.
*/
.twoColElsLt #container { 
	width: 46em;  /* this width will create a container that will fit in an 800px browser window if text is left at browser default font sizes */
	background: #FFFFFF;
	margin: 0 auto; /* the auto margins (in conjunction with a width) center the page */
	border: 1px solid #000000;
	text-align: left; /* this overrides the text-align: center on the body element. */
} 

/* Tips for sidebar1:
1. Be aware that if you set a font-size value on this div, the overall width of the div will be adjusted accordingly.
2. Since we are working in ems, it's best not to use padding on the sidebar itself. It will be added to the width for standards compliant browsers creating an unknown actual width. 
3. Space between the side of the div and the elements within it can be created by placing a left and right margin on those elements as seen in the ".twoColElsLt #sidebar1 p" rule.
*/
.twoColElsLt #sidebar1 {
	float: left;
	width: 12em; /* the background color will be displayed for the length of the content in the column, but no further */
	padding: 15px 0; /* top and bottom padding create visual space within this div */
	background-color: #CCFF99;
}
.twoColElsLt #sidebar1 h3, .twoColElsLt #sidebar1 p {
	margin-left: 10px; /* the left and right margin should be given to every element that will be placed in the side columns */
	margin-right: 10px;
}

/* Tips for mainContent:
1. If you give this #mainContent div a font-size value different than the #sidebar1 div, the margins of the #mainContent div will be based on its font-size and the width of the #sidebar1 div will be based on its font-size. You may wish to adjust the values of these divs.
2. The space between the mainContent and sidebar1 is created with the left margin on the mainContent div.  No matter how much content the sidebar1 div contains, the column space will remain. You can remove this left margin if you want the #mainContent div's text to fill the #sidebar1 space when the content in #sidebar1 ends.
3. To avoid float drop, you may need to test to determine the approximate maximum image/element size since this layout is based on the user's font sizing combined with the values you set. However, if the user has their browser font size set lower than normal, less space will be available in the #mainContent div than you may see on testing.
4. In the Internet Explorer Conditional Comment below, the zoom property is used to give the mainContent "hasLayout." This avoids several IE-specific bugs that may occur.
*/
.twoColElsLt #mainContent {
 	margin: 0 1.5em 0 13em; /* the right margin can be given in ems or pixels. It creates the space down the right side of the page. */
} 

/* Miscellaneous classes for reuse */
.fltrt { /* this class can be used to float an element right in your page. The floated element must precede the element it should be next to on the page. */
	float: right;
	margin-left: 8px;
}
.fltlft { /* this class can be used to float an element left in your page */
	float: left;
	margin-right: 8px;
}
.clearfloat { /* this class should be placed on a div or break element and should be the final element before the close of a container that should fully contain a float */
	clear:both;
    height:0;
    font-size: 1px;
    line-height: 0px;
}
.style1 {font-style: italic}
--> 
</style>
<!--[if IE]>
<style type="text/css"> 
/* place css fixes for all versions of IE in this conditional comment */
.twoColElsLt #sidebar1 { padding-top: 30px; }
.twoColElsLt #mainContent { zoom: 1; padding-top: 15px; }
/* the above proprietary zoom property gives IE the hasLayout it needs to avoid several bugs */
</style>
<![endif]--></head>

<body class="twoColElsLt">

<div id="container">
  <div class="style1" id="sidebar1">
    <h3>Animating a Game Element</h3>
    <p>This lesson shows students how to add an element to a video game and how to animate it on the screen. </p>
    <p>Any element should have some well-defined behavior. In this case, PhotonTorpedoes have a direction they travel and a lifespan.</p>
  </div>
  <div id="mainContent">
    <h1>Fire Photon Torpedo!</h1>
    <p>Part of Asteroids is shooting at the asteroids to break them up before they break up your ship. 
      <!-- end #container -->To do this we must implement a class like the Asteroid class. A class is used to describe what an object is and what it does. The &quot;is&quot; part is the data that the object must keep track of. The &quot;does&quot; part is what we need to tell the object to do to make a photon torpedo fly through space. </p>
    <p>For a torpedo to fly through space it must know the following things:</p>
    <ul>
      <li>It must know its current location in space: an x,y coordinate.</li>
      <li>It must know which direction it is fired (the heading of the torpedo)</li>
      <li>It must also know the speed and direction of the ship it was fired from (you don't want the torpedo to go slower than the ship it was fired from!)</li>
      <li>The Photon Torpedo must know its lifespan because eventually it must fizzle out (you don't want a torpedo to keep flying forever through space).<br />
      </li>
    </ul>
    <p>So, to create a Photon Torpedo  you must provide this information. To do this you might write a statement like this:</p>
    <pre> bullet = PhotonTorpedo(cv,ship.xcor(),ship.ycor(), \
    ship.heading(),ship.getDX(),ship.getDY())
</pre>
    <p>Don't write this code yet. We're not quite ready for changes yet.</p>
    <p>To be able to create a Photon Torpedo we need a constructor for our class that takes the information we provided in the statement above and stores it in the object. The variable called <strong>self</strong> points at the object. To store a value in an object you write</p>
    <p>	self.variable = value</p>
    <p>This stores the <em>value</em> in the object at a place named <em>variable</em>.</p>
    <p>Writing a constructor for the class accomplishes the storing of the values in the object. Here is the constructor for the PhotonTorpedo class. </p>
    <p><strong><em>This code should go right after the statements that set screenMaxX, MinX, MaxY, and MinY at the top of the program.</em></strong></p>
    <pre>class PhotonTorpedo(RawTurtle):
    def __init__(self,canvas,x,y,direction,dx,dy):
        super().__init__(canvas)
        self.penup()
        self.goto(x,y)
        self.setheading(direction)
        self.color(&quot;Green&quot;)
        self.lifespan = 200
        self.dx = math.cos(math.radians(direction)) * 2 + dx
        self.dy = math.sin(math.radians(direction)) * 2 + dy
        self.shape(&quot;bullet&quot;)
    </pre>
    <p>This takes all the information about a PhotonTorpedo and stores it in the PhotonTorpedo object that <strong>self</strong> points to. The line that says <em>super().__init__(self)</em> calls the RawTurtle constructor to initialize the RawTurtle part of the object (since a PhotonTorpedo inherits from a RawTurtle it is also a RawTurtle object). </p>
    <p>The line that starts <strong>self.dx =</strong> sets the amount to add to the torpedoes location each time it is moved. This includes the dx value from the ship plus two times the cosine value for the direction the torpedo was fired. </p>
    <p>The lifespan variable keeps track of how much longer the torpedo should live. </p>
    <p>The code above tells us what a PhotonTorpedo is by storing data in the object. However, there are some things that a PhotonTorpedo must also do. We will need to get some information from the torpedo eventually. We need to know its lifespan and its dx and dy values. We will also need to know how big a PhotonTorpedo is when it collides with something. We'll call this the radius of the torpedo. This means that we need to add some methods to the PhotonTorpedo class. </p>
    <p><strong><em>Here are some methods that must be indented under the PhotonTorpedo class.</em></strong></p>
    <pre>    def getLifeSpan(self):
        return self.lifespan
   
    def getDX(self):
        return self.dx
   
    def getDY(self):
        return self.dy</pre>
    <pre>    def getRadius(self):
        return 4</pre>
    <p>Finally, we need to provide a method to make the PhotonTorpedo move a little bit on the screen so it can be animated by the play function. Photon torpedos move by adding their dx and dy values to the current x and y value of the torpedo. But, each time they move they also decrease their lifespan. </p>
    <p>One interesting thing about Asteroids is that the playing field is wrapped. When a torpedo goes off the right side of the field, it reappears on the left side. The same thing happens with all sides of the field. To do this, it is necessary to use modulo arithmetic. Modulo means that each time we add (or subtract) something to the x or y coordinate we mod it by the width of the playing field to wrap it around.</p>
    <p><em><strong>Here is the code for the move method. Again, it must go inside the PhotonTorpedo class. </strong></em></p>
    <pre>    def move(self):
        self.lifespan = self.lifespan - 1
        screen = self.getscreen()
        x = self.xcor()
        y = self.ycor()</pre>
    <pre>        x = (self.dx + x - screenMinX) %  \
            (screenMaxX - screenMinX) + screenMinX
        y = (self.dy + y - screenMinY) % \
            (screenMaxY - screenMinY) + screenMinY
   
        self.goto(x,y)</pre>
    <p>Now that the PhotonTorpedo class is implemented we can start to use it in our code. To use the class we'll need to keep track of a list of all of our torpedoes. We'll call them bullets in our code. </p>
    <p><em><strong>Find the line that sets the asteroids list to the empty list and make an empty list of bullets.</strong></em></p>
    <pre>    asteroids = [] # This line is already in your program.
    bullets = [] # Add this line!</pre>
    <p>Now, to animate the bullets we must write a loop within the play function to move each of the bullets each time play is called. The asteroids are moved the same way. Here is a loop to move the bullets. The one thing that is different is that bullets eventually die.</p>
    <p><em><strong>	Put this code inside the play function. It can go right after the def play.</strong></em></p>
    <pre>    def play(): # This line is already in your program.</pre>
    <pre>        deadbullets = []</pre>
    <pre>        for bullet in bullets:
            bullet.move()
 
 
            if bullet.getLifeSpan() &lt;= 0:
                deadbullets.append(bullet)</pre>
    <p>When a bullet is dead, it must be removed from the bullet list. To do this, we can add this code right after the code above. This code removes the bullet from the bullet list (called bullets) and then moves the bullet off the screen so it can't be seen anymore. The ht also hides the bullet (which probably doesn't need to be done, since it is off the screen).</p>
    <p><em><strong>Put this code right after the code that you added above. </strong></em></p>
    <pre>        for bullet in deadbullets:
            try:
                bullets.remove(bullet)
            except:
                print(&quot;didn't find bullet&quot;)

            bullet.goto(-screenMinX*2, -screenMinY*2)
            bullet.ht()</pre>
    <p>Finally the only code that is left is to write a little code so when the space bar is pressed it creates a PhotonTorpedo and appends it to the list of bullets. This is very similar to how we got the ship to turn to the right.</p>
    <p><em><strong>Put this code near the end of the program where the other input handlers are written for turning left and right.</strong></em></p>
    <pre>    def fire():
        bullet = PhotonTorpedo(cv,ship.xcor(),ship.ycor(), \
           ship.heading(),ship.getDX(),ship.getDY())
        bullets.append(bullet)
 	
    screen.onkeypress(fire,&quot; &quot;)</pre>
    <p>That should be it. Now you should have a ship that fires torpedoes when you press the space bar!!!</p>
    <h2>Have More Time?</h2>
    <p>Customize the color or shape of your Photon Torpedoes. You could make them more circular, smaller, or bigger. You might also make the torpedoes shoot faster or live longer. </p>
    <p>Give it a try!!!</p>
    <h2>What's Next?</h2>
    <p>Next time we'll make the torpedoes blow up asteroids!</p>
  </div>
  </div>
</body>
</html>
